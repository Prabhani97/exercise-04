<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-02-26">

<title>wordle_Sandani.qmd</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="wordle_Sandani_files/libs/clipboard/clipboard.min.js"></script>
<script src="wordle_Sandani_files/libs/quarto-html/quarto.js"></script>
<script src="wordle_Sandani_files/libs/quarto-html/popper.min.js"></script>
<script src="wordle_Sandani_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="wordle_Sandani_files/libs/quarto-html/anchor.min.js"></script>
<link href="wordle_Sandani_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="wordle_Sandani_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="wordle_Sandani_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="wordle_Sandani_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="wordle_Sandani_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">wordle_Sandani.qmd</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 26, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><em>Note: Prabhani and I discussed and worked together, but we used separate approaches, so that is why we have different files in a shared repo!</em></p>
<p><strong>## Step 1</strong>:</p>
<p><em>Create a custom function called load_dictionary() that takes a single argument, “filename”, to read in either of the two data files:</em>:</p>
<p>I first downloaded the package needed to use the “read_tsv()” function–tidyverse. Then, I used “function()” to create a function called load_dictionary() that uses the argument “filename” to easily load in the data files via their file name. “read_tsv()” will read the text files and assign the output to our new “load_dictionary” function. col_names() is set to TRUE to ensure the first row of the file (“words”) is used as a header.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse) <span class="co"># loading in required package for "read_tsv()"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.6
✔ forcats   1.0.1     ✔ stringr   1.6.0
✔ ggplot2   4.0.1     ✔ tibble    3.3.1
✔ lubridate 1.9.4     ✔ tidyr     1.3.2
✔ purrr     1.2.1     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating a function to read in downloaded data files</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>load_dictionary <span class="ot">&lt;-</span> <span class="cf">function</span>(filename) { <span class="co"># using "filename" as the single argument</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">read_tsv</span>(filename, <span class="at">col_names =</span> <span class="cn">TRUE</span>) <span class="co"># using read_tsv() to load in text files</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Use the function to create two variables, solution_list and valid_list.</em>:</p>
<p>Here, I am creating two variables (“solution_list” and “valid_list”) using our new function. The filenames that were added to our repo are being used as the “filename” argument, meaning they will be passed through the read_tsv() function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating vectors that contain possible valid words from the list of Official Scrabble Words</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>valid_list <span class="ot">&lt;-</span> <span class="fu">load_dictionary</span>(<span class="st">"collins-scrabble-words-2019.txt"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Rows: 279496 Columns: 1
── Column specification ────────────────────────────────────────────────────────
Delimiter: "\t"
chr (1): words

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating vectors that contain possible solution words from the most common words list</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>solution_list <span class="ot">&lt;-</span> <span class="fu">load_dictionary</span>(<span class="st">"google-10000-english-usa-no-swears.txt"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Rows: 9884 Columns: 1
── Column specification ────────────────────────────────────────────────────────
Delimiter: "\t"
chr (1): words

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Checking to see if the function and vectors were made correctly</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># str() will look at the internal structure of our objects</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(valid_list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>spc_tbl_ [279,496 × 1] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ words: chr [1:279496] "AA" "AAH" "AAHED" "AAHING" ...
 - attr(*, "spec")=
  .. cols(
  ..   words = col_character()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; </code></pre>
</div>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(solution_list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>spc_tbl_ [9,884 × 1] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
 $ words: chr [1:9884] "THE" "OF" "AND" "TO" ...
 - attr(*, "spec")=
  .. cols(
  ..   words = col_character()
  .. )
 - attr(*, "problems")=&lt;externalptr&gt; </code></pre>
</div>
</div>
<p><strong>## Step 2</strong>:</p>
<p><em>Winnow your variable solution_list to only include words that are included in valid_list.</em>:</p>
<p>To edit our “solution_list” variable to only contain words from “valid_list,” I am using the intersect() function to find the common elements; I am assigning this to “solution_list”. Since the set operations use vectors as the input, I extracted the elements from the “words” column in our data frame to create character vectors. This was done using “$” extraction operation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the intersect() function to only include words from valid list</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>solution_list <span class="ot">&lt;-</span> <span class="fu">intersect</span>(solution_list<span class="sc">$</span>words, valid_list<span class="sc">$</span>words)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>How many words are in your updated solution_list vector?</em> The solution_list variable went from 9,884 words to 8,336.</p>
<p><strong>## Step 3</strong>:</p>
<p><em>Write a function called pick_solution() that [1] removes words from solution_list that are not 5 letters, [2] randomly chooses a word from those that remain, and [3] splits that word into a vector of single-character elements.</em>:</p>
<p>Here, I am generating a pick solution function that does the three things described above. I have added solution_list and word_length (set to 5) as arguments of the function. word_length make this function more flexible, as it can be set to different values like 3 or 6 to have different word lengths if desired. However, we will keep word_length at its default value for this Wordle challenge.</p>
<p>The first part of the function subsets the solution_list variable to contain only words that are 5 letters long; I do this by extracting from our solution_list variable and applying the baseR function, nchar(), and using our argument word_length, which is set to 5 as default. This is assigned to the same variable “solution_list”.</p>
<p>Then, the function randomly samples the subsetted list to choose one word. This is assigned to an object called “random_word” so only the chosen word will be used as an argument later in the function.</p>
<p>That chosen word is split using the baseR function “strsplit(),” where it takes the subsetted solution_list (the random word) and splits it into single characters (by setting the split argument to ““). Since strsplit() will return a list, [[1]] is added to extract the character vector inside of the list. This is assigned to”split_solution.”</p>
<p>Lastly, the randomly chosen, split word is returned using the return() function. Although this may not be necessary, this was added for good practice! I also assigned the result of the function to a new variable called solution, as directed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating a function that meets the criteria above</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>pick_solution <span class="ot">&lt;-</span> <span class="cf">function</span>(solution_list, <span class="at">word_length =</span> <span class="dv">5</span>) {</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  solution_list <span class="ot">&lt;-</span> solution_list[<span class="fu">nchar</span>(solution_list) <span class="sc">==</span> word_length] <span class="co"># selecting words that are 5 letters in length</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  random_word <span class="ot">&lt;-</span> <span class="fu">sample</span>(solution_list, <span class="at">size =</span> <span class="dv">1</span>) <span class="co"># randomly sampling a word from updated solution_list</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  split_solution <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(random_word, <span class="at">split =</span> <span class="st">""</span>)[[<span class="dv">1</span>]] <span class="co"># splitting chosen word into single-character elements</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(split_solution) <span class="co"># returning a random word that has been split from solution_list</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># assigning the function result to the variable "solution"</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>solution <span class="ot">&lt;-</span> <span class="fu">pick_solution</span>(solution_list)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>## Step 4</strong>:</p>
<p><strong><em>Note: I added the “evaluate_guess()” code chunk first, so it can be run before “play_wordle()”!</em></strong></p>
<p><em>Create two more functions. The first should be called play_wordle() and it should take three arguments: [1] the answer to the puzzle, [2] a list of valid guesses, and [3] a value for “number of guesses”, which you should set to the original Wordle game default of 6.</em>:</p>
<p>I created the “play_wordle()” function by using “function(),” which uses the result of the “pick_solution()” function (assigned to “solution”), the list of valid guesses (“valid_list”), and the number of guesses (set to 6 as default for Wordle), as the arguments.</p>
<p><strong>Inside the function:</strong></p>
<p><strong>Function Setup</strong>:</p>
<p>I began the function by first extracting the words column (using “$”) from valid_list to get a character vector, which is necessary later in the function. I used “toupper” to ensure all the words are uppercase, so that I am working with words and guesses in the same format, ultimately preventing the function from not working due to case sensitivity. This character vector was assigned to “validlistVec.”</p>
<p><em>1. At the onset, tell the player the rules of the game, e.g., “You have … chances to guess a word of length …”</em>: To do this, I use the “print()” and “paste()” functions to tell the number of guesses the player has. I used the paste(), as it allows me to paste strings of characters to the argument “num_guesses,” which is set to 6, into one character string!</p>
<p>I then begin setting up how the function will keep track of the guesses and the letters left. The number of guesses is monitored by the variable “guessNumber,” and is set to 0 first to tell R that the player has not made any guesses yet. The full alphabet is loaded in using the built-in dataset LETTERS, which contains all the letters in uppercase, being consistent with case sensitivity; this was assigned the variable “lettersleft.”</p>
<p>To be able to print out the player’s guess and feedback history, I added the variables “guess_history” and “feedback_history,” which are initially assigned to empty vectors and lists, respectively, to store the game’s progress until it is over.</p>
<p><strong>Game Loop</strong>:</p>
<p><em>2. Display what letters the player has not yet guessed (at the onset, this would be all 26 letters of the alphabet), e.g., “Letters left: …”</em></p>
<p><em>3. Prompt the player for a guess, e.g., “Enter guess number …”, read in their guess, and check that their guess is valid (i.e., that it contains the correct number of letters and is a word included in the “valid” word list).</em>:</p>
<p>To begin the Wordle game loop, I used while loops. This will allow the chunk of code to be repeatedly executed as long as the condition remains. The while loop begins with a conditional statement that will ensure the game continues until the player wins or runs of out guesses. If the player meets that statement, the letters that are still available are displayed using a combination of “print()” and “paste();” collapse() is used to concatenate the elements into a single string to make the output clean and avoid excessive printing. The “guessNumber” variable is then updated by adding 1 every time it goes through the loop to keep track of the guesses. R is then able to see if the number of guesses (by guessNumber) meets the condition statement in the while loop.</p>
<p>The player’s guess is captured through a new variable called “guess.” paste0() is used to create a string using a character string and the value of “guessNumber” to tell the player where they are in the game. readline() allows the player to input their guess in the terminal, allowing the game to be interactive. toupper() was used as a safety net and convert the word to uppercase to account for the different inputs the player might have, such as “Apple,” “apple,” or “APPLE.” If this is not done, R might count these different entries as different words/guesses. This is important for looking through validlistVec later in the function as well.</p>
<p>To ensure that the guess is 5 letters and a valid word, I created another while loop within the while loop. This nestled while loop uses conditional statements: it checks the length of the player’s guess with nchar() and whether it is in the validlistVec using %in%. != and ! is interpreted as NOT, and “||” is the OR operator. If either of these conditions are met (not 5 letters or not in the valid list), a prompt is given, telling the player the rules again. The same guess variable with “readline()” and “toupper()” are used to allow the player to enter another guess that follows the guidelines.</p>
<p>The guess is then split using “strsplit(guess, split =”“)[[1]],” which is assigned to “split_guess.” It does the same thing as before, where it separates the word into single characters; since a list is returned from strsplit() (designed for handling multiple words at once), double brackets are used to give a character vector of the letters. This step is necessary for evaluating the guess in “evaluate_guess()” in element-wise comparisons.</p>
<p><strong>Evaluating the guess with evaluate_guess()</strong>:</p>
<p><em>4. Compare the guess to the solution word and generate the necessary feedback.</em>:</p>
<p>To evaluate the player’s guess and generate feedback, the function “evaluate_guess()” was created. This function was made by using “function()” and using the arguments “split_guess” from “play_wordle()” and solution from “pick_solution.” Within the function, I assign the length of the solution to a variable called “word_length,” which should be 5. I then create a new variable called “response” that will ultimately generate feedback. “rep()” is used to replicate “-” 5 times (length of the word) to initialize the function and assume every letter is wrong.</p>
<p>Two for loops are used in this function. The first pass and for loop is used to make element-wise comparisons between the guess and solution (e.g., the first letter of the guess is compared to the first letter of the solution; the same is done for the second, third, etc.); this is captured by “if(split_guess[i] == solution[i]).” “solution” has already been split by “strsplit()” in “pick_solution().” If they match, “-” changes to “*” in the response, showing that the letter is correct and in the right position. If the condition is not met, the letter in the solution is changed to “-” to mask the letter so it is not counted again in the next loop.</p>
<p>The second for loops looks at the letters that weren’t perfect matches with the position are maybe somewhere else in the word. “if(response[i] !=”*“)” ignores the letters that were already marked as correct. “match(split_guess[i], solution)” looks to see if the current letter is somewhere else in the remaining solution; this is assigned to the variable “position”. If position is not NA, a “+” is added to that position in the response, denoting that the letter is in the word, but in the wrong position. If it is NA, a “-” remains, showing that the letter is in the word; “solution[position]” should account for the amount of times a letter appears in the word (e.g., guessing APPLE when the word would PRICE; accounting for the number of Ps). Lastly, the response is returned using “return()”.</p>
<p><strong>Back to “play_wordle()” game loop</strong>:</p>
<p>In the while loop, “response &lt;- evaluate_guess(split_guess, solution)” passes the guess and the solution to the “evaluate_guess()” function, return a vector of symbols (*,+,-) that denote the correct letters and positions of the guess relative to the solution. This result is stored in the variable “response” so it can be printed to the player and saved in the game history.</p>
<p><em>5. Update the list of letters not yet guessed.</em>:</p>
<p>“lettersleft &lt;- setdiff(lettersleft, split_guess)” updates the available letters left to use from the alphabet. The letters are removed every round based on the player’s guess. “setdiff()” performs a set operation the identifies which characters in the alphabet are not present from the most recent guess, effectively substracting the used letters from the display.</p>
<p>“guess_history &lt;- c(guess_history, guess)” appends the current 5-letter word to the running “guess_history” vector. “c()” combines the existing list of previous guess to the newest guess, creating a chronological history of the player’s guesses. This is a simple vector because it only stores words. “feedback_history[[length(feedback_history) + 1]] &lt;- response” stores the feedback of each guess (a vector of *, +, and -) as a list; “[length(feedback_history) + 1]” in the line of code places the new feedback response in the next part of the list to prevent overwriting the results of previous rounds. This is a list because it store multiple, distinct vectors for each round.</p>
<p>“print(paste(split_guess, collapse =” “))” and “print(paste(response, collapse =” “))” print the internal character vectors into a format that is easily viewed by the player. This combination of “print(),” “paste(),” and “collapse()” prints the letters and the corresponding symbols to be printed in succession, allowing the player to see which letter corresponds with which symbol.</p>
<p><em>6. Check if the puzzle was solved. The function should indicate that the player WON the game and print out their guess and feedback history. If not, the function should prompt the player for another guess, unless they have already hit the maximum number of guesses allowed.</em>:</p>
<p>At the end of the while loop, if the player has solved the puzzle, this is interpreted by the code chunk beginning with ” if(all(response == “*“)) {…” The “all()” function verifies that every character in the feedback vector has the correct position symbol through TRUE/FALSE values. The code then iterates through the stored guess and feedback histories. Lastly, the “return()” function exits the function, preventing further loops and providing the total guess count in the final output. If there is any position that is. + or -, the game continues until the player runs out of guesses.</p>
<p><em>7. If all guesses are exhausted, the function should indicate that the player LOST the game and, again, print out their guess and feedback history.</em>:</p>
<p>If the player runs out of guesses without any successful match, the last code chunk is run (“print(paste(”You LOST :( The answer was”, paste(solution, collapse=““)))…”), as the while loop is terminated (the condition is no longer met). “print(paste(”You LOST :( The answer was”, paste(solution, collapse=““)))” reveals the solution, using a combination of “print()” and “paste()” functions. Then, the code gives the feedback and guess history, stored as a list and vector, respectively. Lastly, the total number of guesses is returned (should be 6).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating a function to evaluate the guess relative to the solution word</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>evaluate_guess <span class="ot">&lt;-</span> <span class="cf">function</span>(split_guess, solution) { <span class="co"># using split_guess and solution as the arguments</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  word_length <span class="ot">&lt;-</span> <span class="fu">length</span>(solution) <span class="co"># assigning the length of the solution to word_length</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  response <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="st">"-"</span>, <span class="at">times =</span> word_length) <span class="co"># initializing, assuming every letter is wrong as default</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># first for loop to find perfect match</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>word_length) { <span class="co"># looks at each position in the 5-letter word</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(split_guess[i] <span class="sc">==</span> solution[i]) { <span class="co"># compares each position between the guess and solution</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      response[i] <span class="ot">&lt;-</span> <span class="st">"*"</span> <span class="co"># for perfect matches </span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      solution[i] <span class="ot">&lt;-</span> <span class="st">"-"</span> <span class="co"># for non-matches</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># second for loop to find correct letters/wrong spots</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>word_length) { <span class="co"># looks at each position in the 5-letter word</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(response[i] <span class="sc">!=</span> <span class="st">"*"</span>) { <span class="co"># ignores perfect matches</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>      position <span class="ot">&lt;-</span> <span class="fu">match</span>(split_guess[i], solution) <span class="co"># looks for current letters anywhere</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.na</span>(position)) {</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        response[i] <span class="ot">&lt;-</span> <span class="st">"+"</span> <span class="co"># for letters in the wrong position</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        solution[position] <span class="ot">&lt;-</span> <span class="st">"-"</span> <span class="co"># for remaining, incorrect letters</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(response)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># creating the main Wordle function</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>play_wordle <span class="ot">&lt;-</span> <span class="cf">function</span>(solution, valid_list, <span class="at">num_guesses =</span> <span class="dv">6</span>) {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># creating a character vector from valid list and ensure they are uppercase</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  validlistVec <span class="ot">&lt;-</span> <span class="fu">toupper</span>(valid_list<span class="sc">$</span>words)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># telling the player game rules</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"You have"</span>, num_guesses, <span class="st">"chances to guess a word of length 5"</span>))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># setting initial guess number and let</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  guessNumber <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  lettersleft <span class="ot">&lt;-</span> LETTERS</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># begin storing guess and feedback histories</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  guess_history <span class="ot">&lt;-</span> <span class="fu">c</span>() <span class="co"># will create a vector of the guesses</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  feedback_history <span class="ot">&lt;-</span> <span class="fu">list</span>() <span class="co"># will create a list of the feedback vectors</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># while loop to repeatedly go through rounds of the game</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(guessNumber <span class="sc">&lt;</span> num_guesses) { <span class="co"># conditional statement to ensure they still have guesses available</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(<span class="fu">paste</span>(<span class="fu">c</span>(<span class="st">"Letters left:"</span>, lettersleft), <span class="at">collapse =</span> <span class="st">" "</span>)) <span class="co"># concatenates and prints remaining letters</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># keeping track of guess number</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    guessNumber <span class="ot">&lt;-</span> guessNumber <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># reading and converting guess to uppercase upon input </span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    guess <span class="ot">&lt;-</span> <span class="fu">toupper</span>(<span class="fu">readline</span>(<span class="fu">paste0</span>(<span class="st">"Enter guess #"</span>, guessNumber, <span class="st">": "</span>)))</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># checking if the guess is 5 letters and in the valid list</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># if not, the prompt restating the rules and another chance is given</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(<span class="fu">nchar</span>(guess) <span class="sc">!=</span> <span class="dv">5</span> <span class="sc">||</span> <span class="sc">!</span>(guess <span class="sc">%in%</span> validlistVec)) {</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>      guess <span class="ot">&lt;-</span> <span class="fu">toupper</span>(<span class="fu">readline</span>(<span class="st">"Your guess must be 5 letters and a valid word: "</span>)) </span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># splitting the guess into single characters for evaluate_guess()</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    split_guess <span class="ot">&lt;-</span> <span class="fu">strsplit</span>(guess, <span class="at">split =</span> <span class="st">""</span>)[[<span class="dv">1</span>]]</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># storing the evaluation of the guess from "evaluate_guess()" into "response"</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>    response <span class="ot">&lt;-</span> <span class="fu">evaluate_guess</span>(split_guess, solution)</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subtracting used letters from the letters left display</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>    lettersleft <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(lettersleft, split_guess)</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># storing the guess history as a vector</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    guess_history <span class="ot">&lt;-</span> <span class="fu">c</span>(guess_history, guess)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># storing the feedback history as a list</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>    feedback_history[[<span class="fu">length</span>(feedback_history) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> response</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print out the guess and response symbols in succession</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(<span class="fu">paste</span>(split_guess, <span class="at">collapse =</span> <span class="st">" "</span>))</span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(<span class="fu">paste</span>(response, <span class="at">collapse =</span> <span class="st">" "</span>))</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># WIN code chunk</span></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">all</span>(response <span class="sc">==</span> <span class="st">"*"</span>)) { <span class="co"># looks to see if all of the characters are in the correct position</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(<span class="st">"You WON! :)"</span>) <span class="co"># if so, it prints this</span></span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(<span class="st">"Feedback history:"</span>) <span class="co"># and the feedback and guess history</span></span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(guess_history)) {</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pastes guess and feedback history for each round together</span></span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span>(<span class="fu">paste</span>(guess_history[i], <span class="st">":"</span>, <span class="fu">paste</span>(feedback_history[[i]], <span class="at">collapse =</span> <span class="st">" "</span>)))</span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(<span class="st">"Total number of guesses:"</span>)</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(guessNumber) <span class="co"># returns total guess number</span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>  <span class="co"># LOST code chunk</span></span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"You LOST :( The answer was"</span>, <span class="fu">paste</span>(solution, <span class="at">collapse=</span><span class="st">""</span>))) <span class="co"># printing solution</span></span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Feedback history:"</span>) <span class="co"># printing feedback and guess history</span></span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(guess_history)) {</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># pastes guess and feedback history for each round together</span></span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(<span class="fu">paste</span>(guess_history[i], <span class="st">":"</span>, <span class="fu">paste</span>(feedback_history[[i]], <span class="at">collapse =</span> <span class="st">" "</span>)))</span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a>  <span class="co"># returning total number of guesses</span></span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="st">"Total number of guesses:"</span>)</span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(guessNumber)</span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># drawing a solution from "pick_solution()"</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>solution <span class="ot">&lt;-</span> <span class="fu">pick_solution</span>(solution_list)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"># using the "play_wordle()" function to play!</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="fu">play_wordle</span>(solution, valid_list) <span class="co"># number of guesses is set to its default of 6</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This was fun!</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>