---
title: "Wordle Game"
format: html
editor: visual
---

## Step 01

Looking at the strucuture of the .txt files given both files contain the word "words" on the top of the given other word lists.

we need a custom function to read these dictionary type text files and to return a character vector containing all the words inside the text files. Also we need to skip the initial heading word.

For that we can use the variable name "text_file_content" and assign the function to it which takes the file name containing the .txt files as an argument. I am using the readLines() function from R to read all text lines inside the files line by line. We skip the word "words" while reading and return the vector.

```{r}
text_file_content <- function(filename) {
  x <- readLines(filename)
  x <- x[x != "words"]      
  return (x)
}
```

Now, I use the created above function to read my actual .txt files "collins-scrabble-words-2019.txt" and "google-10000-english-usa-no-swears.txt" into vectors named valid_list and solution_list respectively.

Also using the sum() function we can test the number of words that have only 5 letters in each file. but there can be words that does not have exactly 5 letters in it in the vectors too.

```{r}
valid_list <- load_dictionary("/Users/pha268/Downloads/ANT 388C/exercise-04/collins-scrabble-words-2019.txt")
solution_list <- load_dictionary("/Users/pha268/Downloads/ANT 388C/exercise-04/google-10000-english-usa-no-swears.txt")

str(valid_list) # Checking data attributes
str(solution_list)

print(solution_list)

sum(nchar(valid_list) == 5) 
sum(nchar(solution_list) == 5)

```

## Step 02

Now I want all solution words we have in the solution_list also to be valid guesses. We have to keep only words that are in both lists for this, because the valid_list contains only the valid words, so by comparing both lists and keeping only words similar to the ones in valid_list will do our task.

This above step is needed to build the wordle game because every solution must be a valid guess.

For this I use, intersect(x,y) function in R, which have the ability to return elements that appear in both vectors x and y inside the function. at the end in the solution_list we have 8336 valid guesses.

```{r}
solution_list <- intersect(solution_list, valid_list)

length(solution_list)

```

## Step 03

Now we need a custom function again to keep words of a specific length when a vector containing words are given as an input argument. We can add a second fixed argument as word_length=5 for this function to default sort words only have 5 letters, which also has a length of the word_length.

After selecting the words of 5 letters from the solution list we need to randomly choose a word as a valid guess (now hat we have only the valid guesses inside the solution_list). I am using sample() function in R to randomly pick a word. This chosen word is our hidden Wordle solution now.

Also, as the next step we need to split tha randomly chosen word in to single letters. For this task we can use strsplit() function in R. And now we can return the splitted word list. We can use \[\[1\]\] to extract the character vector from that list.

```{r}
pick_solution<-function(solution_list, word_length=5){
  five_letter_words<-solution_list[nchar(solution_list)==word_length]
  random_word<-sample(five_letter_words,1)
  random_word_split<-strsplit(random_word,"")[[1]]
  return (random_word_split)
}
```

We provide our solution_list as the first input argument to the above created function ( second argument is fixed).

The returned vector of splitted letters is easy for compare guesses we make in next steps letter by letter.

```{r}
solution<-pick_solution(solution_list)
solution
```

## Step 04

First we define a custom function play_wordle which takes 3 arguments,\[1\] the answer to the puzzle, a list of valid guesses and a value for “number of guesses”.

1\) Giving instruction

2\) displaying what letters left - which he has not guessed yet

3\) Prompting the player for a guess using readline() function, which can take a character string as an argument,

and check that their guess is valid , that it contains the correct number of letters and is a word included in the “valid” word list

4\) Comparing the guess to the solution word and generate the necessary feedback, e.g., `*` for *in the word and in the correct position*, `+` for *in the word but in the wrong position*, and `-` for *not in the word*. For this step, try writing a separate “helper” function, `evaluate_guess()`,

5\) After getting the feedback, for the end game purposes, we add the guessed word in that round and the feedback given from the game for that word to a list, which was initially created as a empty list outside the for loop.

6\) After checking the feedback whether it has 5 "\*"s, we give the feedback as they won or lost along with their guessed word summary and feedbacks given to them.

```{r}
play_wordle <- function(solution, valid_list, num_guesses = 1){
  
  # first step - Explaining the player the rules of the game
  
  word_length<-5
  cat("Hello! Let's play Wordle!!")
  cat("You have", num_guesses, "tries to guess a word of length", word_length, "\n")
  cat("here are the rules!","\n","You will get a * for in the word and in the correct position, + for in the word but in the wrong position, and - for not in the word")
  
  # second step - Displaying what letters the player has not yet guessed
  
  letters_left_to_guess <- LETTERS # built-in dataset, LETTERS, contains the 26 capital letters in the English alphabet 
  
  guessed_words_history <- list()
  feedback_given_history <- list()

  for (guess in 1:num_guesses) {
    cat("\n",guess)
    cat("\n","\n","Letters left:", letters_left_to_guess, "\n")
    
    # third step - Prompting the player for a guess 
    
    cat("Now time to enter your guess !")
    prompt=paste("Please enter your guess number", guess,"and press <enter> : ")
    guessed_word<- readline(prompt)
    guessed_word<-toupper(guessed_word)
    
    # and checking that their guess is valid 
    # First checking word length
    
    if (nchar(guessed_word) != word_length) {
      cat("Wrong length, must be", word_length, "letters.\n\n")
      guess <- guess - 1
      next
    }
    # Next checking of the word is in the valid_list
    
    
    if (!(guessed_word %in% valid_list)) {
      cat("What you entered above is invalid.Please enter a valid word.\n")
      guess<-guess-1
      cat("\n",guess)
      readline( "Please enter a valid word then press <enter>: ")
      next
    }
    
    
    # fourth step - Comparing the guess to the solution word and generate the necessary feedback
      
    output<- evaluate_guess(guessed_word, solution)
    feedback<-output[[1]]
    
    # Appending guessed word in that round and the feedback to a list to show at the end
    
    guessed_words_history <- append(guessed_words_history, guessed_word)
    feedback_given_history <- append(feedback_given_history, feedback)
    
    # Shwoing letters left to guess
    
    letters_left <- setdiff(letters_left_to_guess, unique(guessed_letters))
    
    # Checking for feedback 
    
    if (all(feedback == "*")){
      print("You won the game by guessing the correct word!!")
      cat("Your guesses in the game are:", for (i in guessed_words_history){print(guessed_words_history[i])}, "\n","feedbacks given are:", for (i in feedback_given_history){print(feedback_given_history[i])},"\n")
    }
    
  }
  
  print("You lost the game!")
  
  cat("Your guesses in the game are:", for (i in guessed_words_history){print(guessed_words_history[i])}, "\n","feedbacks given are:", for (i in feedback_given_history){print(feedback_given_history[i])},"\n")
}
```

Defining the additional function needed to check the guessed word. This function takes, as arguments, the player’s guess and the value of the **solution** variable.

Here my guessed word is format of "HELLO", my solution I get from pick_solution() fucntion is format of "R" "O" "C" "K" "S". I need to make the formats similar in order to compare. We can accomplish strsplit() the guessed word.

So, I convert guessed word into the format of solution. Then we can compare in a for loop and give feedback.

\# Creating a n length string as feedback comprised of "-"s, so that we can replace with "\*" and "+"s after checking.

Our 1st step- Checking for correct letters in correct positions and replacing them with a "\*"

2nd approach - checking for correct letters but not in the correct positions

**first approach** - when checking for correct letters in correct positions and correct letters in wrong positions I did not consider removing the ideally matched letter from the original solution word, it caused me a problem in second step as identifying the same letter as a correct letter in a wrong position if we had the same letter twice in the word.

example: if our guessed_word_test was "AGAIN" and solution_test was the list("C","L","A","S","S") it gave the feedback of "+" "-" "+" "-" "-", which was misleading, which lead to player think there are two "A"s in the solution.

**second approach** - when checking for correct letters in correct positions and correct letters in wrong positions I did consider removing the ideally matched letter from the original solution word, above problem did not occur. then the feedback was "-" "-" "+" "-" "-". This does not give the impression of having two "A"s in the word.

**third approach** - when trying to compare the guessed word "PLAZA" and solution_test was the list("R","A","I","S","E"), feedback was "-" "-" "+" "-" "+", this was also a problem for me. When we reached Jamie about it she said this extent is not necessary to be solved.

```{r}
evaluate_guess<- function(guessed_word, solution){
  
  guessed_letters <- strsplit(guessed_word, split = "")[[1]] #converting guessed word into the format of solution.
  
  n <- length(solution)
  feedback<-rep("-",n)
  
  
  
  # Checking for correct letters in correct positions
  
  for (i in 1:n){
    if (guessed_letters[i] == solution[i]) {
      feedback[i] <- "*"
      solution[i]<- "INV"
      
    }
  }
  
  # Now checking for correct letters but not in the correct positions, using a loop inside a loop what I want to do is try to match letters in guessed_word and the solution one to one.
  
  for (i in 1:n){
    for (j in 1:n){
      if (guessed_letters[j]== solution[i]){
        feedback[j] <- "+"
        
        
      }
    }

  }
  
  final_solution<- paste(solution, collapse = " ") # I need to return both feedback and solution from the function.
  
  output <- list(feedback, final_solution)
  return(output)
  
  
  
}
```

```{r}
guessed_word_test<-"PLAZA"
solution_test<-list("C","L","A","S","S")
output<-evaluate_guess(guessed_word_test,solution_test)
output

```

```{r}

feedback<-play_wordle(solution,valid_list)
feedback
```
